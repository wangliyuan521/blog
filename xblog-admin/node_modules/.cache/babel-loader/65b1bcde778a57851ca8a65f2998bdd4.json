{"remainingRequest":"D:\\xblog\\xblog-admin\\node_modules\\babel-loader\\lib\\index.js!D:\\xblog\\xblog-admin\\node_modules\\eslint-loader\\index.js??ref--13-0!D:\\xblog\\xblog-admin\\src\\utils\\utf8.js","dependencies":[{"path":"D:\\xblog\\xblog-admin\\src\\utils\\utf8.js","mtime":1583590624585},{"path":"D:\\xblog\\xblog-admin\\node_modules\\cache-loader\\dist\\cjs.js","mtime":499162500000},{"path":"D:\\xblog\\xblog-admin\\node_modules\\babel-loader\\lib\\index.js","mtime":499162500000},{"path":"D:\\xblog\\xblog-admin\\node_modules\\eslint-loader\\index.js","mtime":499162500000}],"contextDependencies":[],"result":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toByteStringUTF8 = toByteStringUTF8;\n\nrequire(\"core-js/modules/es7.symbol.async-iterator\");\n\nrequire(\"core-js/modules/es6.symbol\");\n\nrequire(\"core-js/modules/web.dom.iterable\");\n\n/**\r\n * Make sure the charset of the page using this script is\r\n * set to utf-8 or you will not get the correct results.\r\n */\nvar highSurrogateMin = 0xd800;\nvar highSurrogateMax = 0xdbff;\nvar lowSurrogateMin = 0xdc00;\nvar lowSurrogateMax = 0xdfff;\nvar surrogateBase = 0x10000;\n\nfunction isHighSurrogate(charCode) {\n  return highSurrogateMin <= charCode && charCode <= highSurrogateMax;\n}\n\nfunction isLowSurrogate(charCode) {\n  return lowSurrogateMin <= charCode && charCode <= lowSurrogateMax;\n}\n\nfunction combineSurrogate(high, low) {\n  return (high - highSurrogateMin << 10) + (low - lowSurrogateMin) + surrogateBase;\n}\n/**\r\n * Convert JavaScript String to an Array of\r\n * UTF8 bytes\r\n * @export\r\n */\n\n\nfunction stringToBytes(str) {\n  var bytes = [];\n  var strLength = str.length;\n  var strIndex = 0;\n  var charCode;\n  var charCode2;\n\n  while (strIndex < strLength) {\n    charCode = str.charCodeAt(strIndex++); // handle surrogate pair\n\n    if (isHighSurrogate(charCode)) {\n      if (strIndex === strLength) {\n        throw new Error('Invalid format');\n      }\n\n      charCode2 = str.charCodeAt(strIndex++);\n\n      if (!isLowSurrogate(charCode2)) {\n        throw new Error('Invalid format');\n      }\n\n      charCode = combineSurrogate(charCode, charCode2);\n    } // convert charCode to UTF8 bytes\n\n\n    if (charCode < 0x80) {\n      // one byte\n      bytes.push(charCode);\n    } else if (charCode < 0x800) {\n      // two bytes\n      bytes.push(0xc0 | charCode >> 6);\n      bytes.push(0x80 | charCode & 0x3f);\n    } else if (charCode < 0x10000) {\n      // three bytes\n      bytes.push(0xe0 | charCode >> 12);\n      bytes.push(0x80 | charCode >> 6 & 0x3f);\n      bytes.push(0x80 | charCode & 0x3f);\n    } else {\n      // four bytes\n      bytes.push(0xf0 | charCode >> 18);\n      bytes.push(0x80 | charCode >> 12 & 0x3f);\n      bytes.push(0x80 | charCode >> 6 & 0x3f);\n      bytes.push(0x80 | charCode & 0x3f);\n    }\n  }\n\n  return bytes;\n}\n\nfunction toByteStringUTF8(string) {\n  if (string === '' || string === undefined) return '';\n  var arr = stringToBytes(string);\n  var result = '';\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = arr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var key = _step.value;\n      result += key;\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  return result;\n}",null]}